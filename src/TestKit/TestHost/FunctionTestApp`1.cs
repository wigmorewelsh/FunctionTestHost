using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using FunctionMetadataEndpoint;
using Grpc.Net.Client;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using Orleans;
using TestKit.Actors;
using TestKit.MetadataClient;
using TestKit.Utils;

namespace TestKit.TestHost;

public class FunctionTestApp<TStartup> : FunctionTestApp, ITestHostBuilder
{
    private readonly IConfigureFunctionTestHost _functionTestHost;
    private AsyncLock _lock = new();
    private volatile bool _isInit = false;
    private IHost _functionHost;
    private Action<IHostBuilder>? _serviceConfiguration;

    public FunctionTestApp(IConfigureFunctionTestHost functionTestHost)
    {
        Environment.SetEnvironmentVariable("FUNCTIONS_APPLICATION_DIRECTORY", Environment.CurrentDirectory);
        Environment.SetEnvironmentVariable("FUNCTIONS_WORKER_DIRECTORY", Environment.CurrentDirectory);
        _functionTestHost = functionTestHost;
    }

    public async Task Start(IGrainFactory grainFactory)
    {
        if(_isInit) return;
        using var _ = await _lock.LockAsync();
        if(_isInit) return;

        var workerid = Guid.NewGuid().ToString();
        
        var builder = HostFactoryResolver.ResolveHostBuilderFactory<IHostBuilder>(typeof(TStartup).Assembly);
        var configureServices = builder(Array.Empty<string>())
            .ConfigureAppConfiguration(config =>
            {
                config.AddInMemoryCollection(new Dictionary<string, string>
                {
                    ["Host"] = "localhost",
                    ["Port"] = _functionTestHost.HostPorts.Item1.ToString(),
                    ["WorkerId"] = workerid,
                    ["GrpcMaxMessageLength"] = (2_147_483_647).ToString()
                });
            })
            .ConfigureServices((host, services) =>
            {
                services.Configure<GrpcWorkerStartupOptions>(host.Configuration);
                services.AddSingleton(ctx =>
                {
                    var options = ctx.GetRequiredService<IOptions<GrpcWorkerStartupOptions>>();
                    var url = new Uri($"http://{options.Value.Host}:{options.Value.Port}");
                    var channel = GrpcChannel.ForAddress(url, new GrpcChannelOptions());
                    return new FunctionRpc.FunctionRpcClient(channel);
                });
            });
        
        if (!TryInvokeAutoGeneratedConfigureMethods(configureServices))
        {
            configureServices.ConfigureServices((host, services) =>
            {
                services.AddHostedService<MetadataClientRpc<TStartup>>();
            });
        }
        
        _serviceConfiguration?.Invoke(configureServices);
        _functionHost = configureServices
            .Build();

        await _functionHost.StartAsync();

        var functionGrain = grainFactory.GetGrain<IFunctionInstanceGrain>(workerid);
        await functionGrain.Ping();
        
        _isInit = true;
    }

    /// <summary>
    /// Invokes auto-generated configuration methods for a given <see cref="IHostBuilder"/>.
    /// This method searches for classes that implement the <see cref="IAutoConfigureStartup"/> interface,
    /// excluding interfaces and abstract classes. For each identified class, it locates the
    /// <c>Configure</c> method with the signature <c>void Configure(IHostBuilder hostBuilder)</c>,
    /// and executes the method using an instance of the class.
    /// </summary>
    /// <param name="builder">The <see cref="IHostBuilder"/> to configure.</param>
    /// <returns>The same <see cref="IHostBuilder"/> after the auto-generated configuration methods are invoked.</returns>
    public static bool TryInvokeAutoGeneratedConfigureMethods(IHostBuilder builder)
    {
        try
        {
            var autoConfigureStartupTypes = typeof(TStartup).Assembly 
                .GetTypes()
                .Where(t => t.GetInterfaces().Any(i => i.FullName == "Microsoft.Azure.Functions.Worker.IAutoConfigureStartup") &&
                            !t.IsInterface && !t.IsAbstract);

            foreach (var type in autoConfigureStartupTypes)
            {
                dynamic instance = Activator.CreateInstance(type)!;
                instance.Configure(builder);
            }

            return autoConfigureStartupTypes.Any();
        } 
        catch (Exception e)
        {
            Console.WriteLine(e);
        }

        return false;
    }
    
    public IServiceProvider Services => _functionHost.Services;

    public async ValueTask DisposeAsync()
    {
        await _functionHost.StopAsync(TimeSpan.Zero);
    }

    public ITestHostBuilder WithServiceConfiguration(Action<IHostBuilder> action)
    {
        _serviceConfiguration = action;
        return this;
    }
}